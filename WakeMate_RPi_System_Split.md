# 🚗 WakeMate 기능 분할 설계 (Raspberry Pi 2대 구성)
---
# 🧠 WakeMate 프로젝트 기능 설명 및 보드 역할 분리

## ✅ 기능 1: 졸음 감지 → 대화 유도 (ChatGPT와 상호작용)

### 🧩 목표
- 운전자가 졸음 상태일 때 시스템이 먼저 말을 걸고,
- 운전자가 응답하면 계속해서 대화를 이어가며 졸음을 방지하는 기능

### 🧪 작동 흐름 (세부 설명)

| 단계 | 설명 | 처리 보드 |
|------|------|------------|
| 1 | 졸음 감지: YOLO/DMS 모델로 눈 감김 등 졸음 상태 감지 | rasp1 |
| 2 | GPT API 요청: 감지되면 GPT에 "내가 피곤하다. 말 걸어달라" 전송 | rasp1 |
| 3 | GPT 응답 수신: 예 "졸리면 스트레칭 해보는 건 어때요?" | rasp1 |
| 4 | TTS 요청: 응답 문장을 Google TTS로 변환 요청 | rasp1 → rasp2 |
| 5 | TTS 음성 생성 및 출력: 음성 파일 생성 → 스피커 출력 | rasp2 |
| 6 | 운전자가 말함: 예 "좋은 생각이에요" | rasp2 (녹음) |
| 7 | STT 처리: 음성 → 텍스트 변환 | rasp2 |
| 8 | 텍스트 → rasp1 전송 | rasp2 → rasp1 |
| 9 | GPT에 전송 → 응답 받음 | rasp1 |
| 10 | 다시 TTS 요청 → 음성 출력 | rasp1 + rasp2 |

### 💡 핵심 포인트
- **rasp1**: 뇌 (졸음 감지 + GPT 처리 + 음성 생성 요청)
- **rasp2**: 입/귀 (TTS 음성 출력 + 운전자 음성 수신 및 텍스트 전환)

---

## ✅ 기능 2: 졸음 감지가 없는 평소, 음성으로 액추에이터 제어 (CAN 통신)

### 🧩 목표
- 운전자가 음성으로 “에어컨 켜줘” → 차량 기능을 제어

### 🧪 작동 흐름 (세부 설명)

| 단계 | 설명 | 처리 보드 |
|------|------|------------|
| 1 | 운전자가 말함: “창문 열어줘” | rasp1 |
| 2 | STT 처리: Google STT API로 텍스트 변환 | rasp1 |
| 3 | 명령 분석: 텍스트 파싱 → 명령 판단 | rasp1 |
| 4 | CAN 메시지 생성: ID=0x100, Data=[0x01] | rasp1 |
| 5 | CAN 메시지 전송: MCP2515로 전송 | rasp1 |
| 6 | CAN 메시지 수신: MCP2515 수신 | rasp2 |
| 7 | 메시지 해석 및 실행: ID 분석 → GPIO 제어 | rasp2 |

### 💡 핵심 포인트
- **rasp1**: 명령 인식 및 생성기
- **rasp2**: 실질적인 차량 액추에이터 컨트롤러

---

## 📦 보드 역할 최종 정리

| 보드 | 주요 역할 | 상세 기능 |
|------|------------|-------------|
| **rasp1 (두뇌)** | 졸음 감지 / 음성 인식 / GPT 처리 / 명령 생성 | YOLO, STT, GPT API, CAN 송신 |
| **rasp2 (팔/입/귀)** | 음성 출력 / 액추에이터 실행 | TTS 출력, 마이크 녹음, STT 처리, CAN 수신 + GPIO 제어 |

---

## 🔁 두 보드 간 통신 요약

| 통신 목적 | 방향 | 방법 (예시) |
|-------------|--------|------------------|
| TTS 요청 전송 | rasp1 → rasp2 | TCP 소켓 or 텍스트 파일 |
| STT 결과 전달 | rasp2 → rasp1 | TCP or 공유 디렉토리 |
| 액추에이터 명령 | rasp1 → rasp2 | CAN 메시지 전송 (MCP2515) |

---

## 🛠️ 예시 시나리오 요약

### 1. 졸음 감지 시나리오
- rasp1: 졸음 감지 → GPT API → 응답
- rasp2: 응답 음성 출력
- rasp2: 사용자 응답 수신(STT) → rasp1 전달 → 다음 GPT 응답

### 2. 음성 제어 시나리오
- rasp1: “창문 열어줘” STT 처리 → CAN 메시지 생성 및 전송
- rasp2: 메시지 수신 → GPIO로 창문 모터 제어
---
## 🎯 구현 기능 개요

### ✅ 기능 ①: 졸음 감지 기반 대화형 운전자 케어
- 졸음 감지 → GPT API에 “내가 피곤하다. 말 걸어 달라” 전송
- GPT 응답 → Google TTS → 음성 출력
- 운전자의 음성 → Google STT → GPT → TTS 반복

### ✅ 기능 ②: 음성 기반 액추에이터 제어 (졸음 감지 없이)
- 운전자가 음성으로 명령 (예: "에어컨 켜줘")
- STT로 텍스트 변환 → CAN 메시지 생성 및 전송
- 수신 보드에서 CAN 수신 → GPIO 제어

---

## 🧠 시스템 분할 전략

| 역할 | Rasp1 (Vision + Command Unit) | Rasp2 (Actuator + TTS Unit) |
|------|-------------------------------|------------------------------|
| 🎥 졸음 감지 | ✅ YOLO/DMS | ❌ |
| 🎙️ 음성 입력 | ✅ STT (Google) | ✅ STT (단일 명령어 수준) |
| 💬 GPT API 요청 | ✅ (대화 흐름 제어) | ❌ |
| 🔊 TTS 및 음성 출력 | ❌ | ✅ Google TTS + 출력 |
| 🛰️ CAN 통신 | ✅ 송신 (명령 생성) | ✅ 수신 (GPIO 실행) |
| ⚙️ 액추에이터 제어 | ❌ | ✅ GPIO 제어 |
| 🔁 대화 반복 루프 | GPT ↔ STT 관리 | TTS ↔ 출력 관리 |

---

## 📦 기능 ① 흐름: 졸음 감지 대화 루프

```text
[rasp1]
카메라 → 졸음 감지
↓
GPT API 요청: "내가 피곤하다. 말 걸어 달라"
↓
응답 텍스트
↓
TTS 요청 전달 →
                   [rasp2]
                   Google TTS로 음성 생성
                   ↓
                   스피커 출력
                   ↓
                   운전자의 음성
                   ↓
                   Google STT
                   ↓
                   텍스트 → rasp1에 전달 →
                                        GPT 응답 →
                                        TTS 요청 →
                                        (반복)
```

---

## 📦 기능 ② 흐름: 음성 명령 기반 엑추에이터 제어

```text
[rasp1]
운전자: “에어컨 켜줘”
↓
Google STT
↓
텍스트 해석 → 명령 매핑
↓
CAN 메시지 전송: ID=0x300, data=0x01
↓
                   [rasp2]
                   CAN 수신
                   ↓
                   해당 GPIO 제어 (팬 ON 등)
```

---

## ✅ 결론 요약

| 보드 | 주요 구성 | 담당 기능 |
|------|------------|------------|
| **rasp1** | Camera, STT, GPT, CAN 송신 | 졸음 감지, 명령 생성, 대화 흐름 제어, CAN 제어 발신 |
| **rasp2** | MCP2515, 스피커, TTS, GPIO | CAN 수신 및 액추에이터 실행, TTS 및 음성 출력 |

---

## 💡 추가 팁
- TTS는 `rasp2`에서 수행하여 하드웨어 동작과 음성 출력을 한 번에 처리
- 필요 시 rasp1 ↔ rasp2 간 TCP 통신 보조 가능 (대화 흐름 제어 확장)
